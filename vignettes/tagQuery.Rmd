---
title: "Using tagQuery() to query and modify HTML tags"
output: html_document
---

```{r, include=FALSE}
library(knitr)
library(htmltools)
opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "100%",
  fig.align = 'center'
)
# Show R console output instead of embedding the HTML
registerS3method(
  "knit_print", "shiny.tag",
  getS3method("print", "shiny.tag")
)
registerS3method(
  "knit_print", "shiny.tag.list",
  getS3method("print", "shiny.tag.list")
)
```

`tagQuery()` provides a [jQuery](https://jquery.com) inspired interface to query and modify HTML fragments in R. To start, pass either a `tag()` (e.g., `div()`) or `tagList()` object to `tagQuery()`:

```{r}
library(htmltools)
tagQuery(div(a()))
```

Notice how `tagQuery()` tracks two essential pieces: the input tag(s) as well as _selected_ tags (by default the input tag(s) are selected). This data structure allows us to [efficiently](#performance) [query](#query), [modify](#modify), and [replace](#replace) particular fragments of the root HTML tag.

Since `tagQuery()` isn't itself a `tag()` object, it can't be passed directly to `tag()` or tag rendering functions, but at any given time you can extract `$allTags()` or the `$selectedTags()`.

## Query {#query}

`tagQuery()` has numerous methods to select (i.e., query) HTML tag(s). Every query method accepts a [CSS selector](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors) for targeting particular tags of interest. At the moment, `tagQuery()` only supports a combination of [type](https://www.w3.org/TR/CSS22/selector.html#type-selectors) (e.g, `div`), [class](https://www.w3.org/TR/CSS22/selector.html#class-html) (e.g., `.my-class`), [id](https://www.w3.org/TR/CSS22/selector.html#id-selectors) (e.g., `#myID`), and [universal](https://www.w3.org/TR/CSS22/selector.html#universal-selector) (`*`) selectors within a given [simple selector](https://www.w3.org/TR/CSS22/selector.html#selector-syntax).

### Children

To begin querying tags, start with either `$find()` or `$children()`. The former traverses _all_ descendants whereas the latter only considers _direct_ descendants.

```{r}
(html <- div(span("foo"), div(span("bar"))))
```

```{r}
tagQ <- tagQuery(html)
tagQ$find("span")$selectedTags()
tagQ$children("span")$selectedTags()
```

And since `$find()` considers all descendants, it allows for [descendant selectors](https://www.w3.org/TR/CSS22/selector.html#descendant-selectors) (space) and direct [child selectors](https://www.w3.org/TR/CSS22/selector.html#child-selectors) (>).

```{r}
(html <- div(div(span(a()))))
```

```{r}
tagQ <- tagQuery(html)
tagQ$find("div a")$selectedTags()
tagQ$find("div > a")$selectedTags()
tagQ$find("div > span > a")$selectedTags()
```

Since `tagQuery()` methods may be chained together, you could also implement  `tagQ$find("div > span > a")` as:

```{r}
tagQ$find("div")$children("span")$children("a")$selectedTags()
```

### Siblings

Although `tagQuery()` doesn't (currently) support [sibling selectors](https://www.w3schools.com/css/css_combinators.asp) (`+` and `~`), it does provide a `$sibling()` method, which provides essentially the same functionality:

```{r}
(html <- div(a(), span(), p()))
```

```{r}
tagQ <- tagQuery(html)
# The moral equivalent to `tagQ$find("a ~ span")`
tagQ$find("a")$siblings("span")$selectedTags()
```

### Parents

In some cases, after finding children, it can be useful to traverse back up the tag tree to find particular ancestors of a selection. Similar to the difference in `$find()` and `$children()`, `$parents()` traverses _all_ ancestors whereas `$parent()` considers just _direct_ ancestors.

```{r}
(html <- div(div(a(class = "foo")), span(a())))
```

```{r}
tagQ <- tagQuery(html)
tagQ$find("a.foo")$parent()$selectedTags()
tagQ$find("a.foo")$parents()$selectedTags()
```

<!-- TODO: worth mentioning closest()? -->

### Filter

The `$filter()` method can be used to subset selected tags using an R function or CSS selector. When combined with the universal selector (`*`), `$filter()` is particularly useful as a workaround for the fact that `tagQuery()` doesn't fully support the entire CSS selector specification. For example, here's a workaround for `tagQuery()`'s current lack of support for [attribute selectors](https://www.w3.org/TR/CSS22/selector.html#attribute-selectors):

```{r}
(html <- div(div(), div("data-foo" = "bar")))
```

```{r}
tagQ <- tagQuery(html)
# The moral equivalent to `tagQ$find("[data-foo]")`
tagQ$
  find("*")$
  filter(function(x, i) tagHasAttribute(x, "data-foo"))$
  selectedTags()
```

### Reset

To reset the set of selected tags to the root tag, use `$resetSelected()`:

```{r}
(html <- div(a()))
```

```{r}
tagQ <- tagQuery(html)$find("a")
tagQ$selectedTags()
tagQ$resetSelected()$selectedTags()
```


## Modify {#modify}

`tagQuery()` provides numerous functions for modifying HTML [attributes](#modify-attrs), [children](#modify-child), or [sibling](#modify-sibling) tags of the current query selection. Unlike query methods, modifier methods _modify their input_ (both the root and the selection). For example, note how the `$addClass()` call here modifies `tagQ` (but `$find()` doesn't):

```{r}
(html <- div(a()))
```

```{r}
tagQ <- tagQuery(html)
tagQ$
  find("a")$
  addClass("foo")$
  allTags()
```

The [mutable](https://en.wikipedia.org/wiki/Immutable_object) behavior of modifier methods not only allows us to modify child tags without losing a reference to the root tag, but it also makes modifications more [performant](#mutate-in-place) than they'd otherwise be.

### Attributes {#modify-attrs}

Use `$addAttrs()` to add and `$removeAttrs()` to remove any HTML attribute from each selected tag. If you're just working with `class` attributes, consider using the more convenient `$addClass()`, `$removeClass()`, or `$toggleClass()`

```{r}
(html <- div(span(a()), span()))
```

```{r}
tagQ <- tagQuery(html)
tagQ$
  find("span")$
  addAttrs("data-bar" = "foo")$
  allTags()
```

Also, to check whether each selected tag has a certain attribute, use `$hasAttr()` (or `$hasClass()`)

```{r}
tagQ$find("span")$hasAttr("data-bar")
```

### Children {#modify-child}

Use `$prepend()` to insert content before the children of each selected tag and `$append()` to insert content after:

```{r}
(html <- div(p(a())))
```

```{r}
tagQ <- tagQuery(html)
tagQ$
  find("p")$
  prepend(span())$
  append(tags$table())$
  allTags()
```

If you'd like to replace all the children, then you can first call `$empty()` before `$append()`. If you like to just remove particular child tags, then you should call `$children()` + the `$remove()` sibling method.

### Siblings {#modify-sibling}

Use `$before()` to insert content before each selected tag and `$after()` to insert content after:

```{r}
(html <- div(p(a())))
```

```{r}
tagQ <- tagQuery(html)
tagQ$
  find("a")$
  before(span())$
  after(tags$table())$
  allTags()
```

## Replace {#replace}

As with `tagQuery()`'s modifier methods, its replace methods also modify their input. They also empty selected tags, so you may want to `$resetSelection()` if you want to make more queries or modifications after-the-fact.

Use `$replaceWith()` to replace selected tags with some other content.

```{r}
(html <- div(a()))
```

```{r}
tagQ <- tagQuery(html)
tagQ$
  find("a")$
  replaceWith(p())$
  allTags()
```

Use `$remove()` to replace selected tags with nothing:

```{r}
tagQ <- tagQuery(html)
tagQ$find("a")$remove()$allTags()
```

And use `$empty()` to replace the _children_ of the selected tags with nothing:

```{r}
(html <- div(span(a())))
```

```{r}
tagQ <- tagQuery(html)
tagQ$find("span")$empty()$allTags()
```


## Performance {#performance}


`tagQuery()` is very fast, given the dynamic usage.  Let's look at performance to add a set the main button class for a `shiny` action button:

```{r}
# Show the original tags
shiny::actionButton("myID", "myLabel")
# Benchmark operations
microbenchmark::microbenchmark(
  create_button =
    shiny::actionButton("myID", "myLabel"),
  and_call_tagQuery =
    tagQuery(shiny::actionButton("myID", "myLabel"))$
      allTags(),
  and_add_class =
    tagQuery(shiny::actionButton("myID", "myLabel"))$
      addClass("btn-primary")$
      allTags(),
  and_remove_class =
    tagQuery(shiny::actionButton("myID", "myLabel"))$
      addClass("btn-primary")$
      removeClass("btn-default")$
      allTags()
)
# Final output
tagQuery(shiny::actionButton("myID", "myLabel"))$
  addClass("btn-primary")$
  removeClass("btn-default")$
  allTags()
```

While there is some overhead to turn a standard `tag` object into a `tagQuery()` object, all operations finish within 1 millisecond.

While adding the `btn-primary` class could be accomplished using `tagAddAttributes(myButton, class="btn-primary")`, removing a class is currently not possible without reaching into the attributes of the button object.

Let's look at a more complicated example: `shiny::dateRangeInput()`. For this example, we are going to update the `title` attribute for each date input say `"Start Date"` or `"End Date"`.

```{r}
# Show the original tags
startDate <- "2001-01-01"; endDate <- "2010-12-31"
(dateRange <- shiny::dateRangeInput(
  "daterange", "Date range:",
  start = startDate, end = endDate
))
# Benchmark operations
microbenchmark::microbenchmark(
  call_tagQuery =
    tagQuery(dateRange)$allTags(),
  and_find_input =
    tagQuery(dateRange)$find("input")$allTags(),
  and_remove_title =
    tagQuery(dateRange)$find("input")$removeAttrs("title")$allTags(),
  and_call_each =
    tagQuery(dateRange)$
      find("input")$
      removeAttrs("title")$
      each(function(el, i){
        newTitle <- c("Start Date", "End Date")[i]
        tagAppendAttributes(el, title = newTitle)
      })$
      allTags()
)
# Final output
dateRangeQ <- tagQuery(dateRange)$
  find("input")$
  removeAttrs("title")$
  each(function(el, i) {
    newTitle <- c("Start Date", "End Date")[i]
        tagAppendAttributes(el, title = newTitle)
  })$
  allTags()
dateRangeQ

# waldo::compare(dateRange, dateRangeQ)
#> `old$children[[2]]$children[[1]]$attribs$title`: "Date format: yyyy-mm-dd"
#> `new$children[[2]]$children[[1]]$attribs$title`: "Start Date"
#> `old$children[[2]]$children[[3]]$attribs$title`: "Date format: yyyy-mm-dd"
#> `new$children[[2]]$children[[3]]$attribs$title`: "End Date"
```


Updating the `title`s for each of the `<inputs>` could be done manually. However, this is brittle to developer changes and is difficult to debug.  Taking a quick glance at the code below. We can tell the `title` attributes are being updated, but there is no hint as to which tags are being operated on.  This would only become more difficult to determine the larger the tag objects grow.

```{r}
microbenchmark::microbenchmark(
  unclear_and_brittle = {
    # Unclear and very brittle operations
    dateRange$children[[2]]$children[[1]]$attribs$title <- "Start Date"
    dateRange$children[[2]]$children[[3]]$attribs$title <- "End Date"
    dateRange
  }
)
```

If you would like to do more complicated alterations to the selected tag, you can send `el` to `tagQuery()` and immediately gain access to all selected element methods. While `tagAppendAttributes()` was sufficient above, `tagQuery(el)$addAttrs(title = newTitle)` could also be used at a slight speed cost (~500 μs).

```{r}
microbenchmark::microbenchmark(
  "$addAttrs()" = {
    tagQuery(dateRange)$
      find("input")$
      removeAttrs("title")$
      each(function(el, i) {
        newTitle <- c("Start Date", "End Date")[i]
        tagQuery(el)$addAttrs(title = newTitle)
      })$
      allTags()
  }
)
```


At worst, using `tagQuery()` in this example increases the execution time by roughly 3-4 times, from 1.5 milliseconds to 5.5 milliseconds.

### Mutate in-place {#mutate-in-place}

The final output of the `dateRangeInput` example above uses multiple steps. Let's break down cost and benefits of each one.

1. `tagQuery(dateRange)`: ~500 μs. Convert all tag objects into `tagQuery()` objects. The cost advantage is to be able to keep track of all tag objects and be able to alter the `tagQuery()` object in place. This method also unifies the `children` tag structure by flattening all children into a single level. This makes traversing **much** faster.
2. `$find("input")`: ~500μs. Finds **all** matching tags that match the css selector `"input"`. This method updates the selected items to the two `<input>` tags.
3. `$removeAttrs("title")`: ~50μs. Removes the `"title"` attribute from both of the selected `<input>` tags. Since the selected items have already been flagged, this method is fairly quick! This method maintains the selected tags and passes on the `tagQuery()` structure.
4. `$each(fn)`: ~250μs. Given a selected tag, the function calls `tagQuery()` on the selected tag to leverage `tagQuery()`s methods to remove and add attributes on the selected tags. Since a "modify in place" selected tag is provided directly to `tagQuery()`, it is fast to create.  However, extra care is taken by `tagQuery()` after calling `$each()` to make sure the internal `tagQuery()` structure is still intact. This is due to `$each()` being able to reach into and alter all parent and children tags of the selected tags. This extra bit of housekeeping has a necessary, but small overhead.

If `htmltools` was to not leverage "modify in place" data structures, `htmltools` would have to constantly search every time a selected element was to be modified.  Using the same example as above, finding the `<input>` tags will still require ~500 μs to prep the tag objects. It would also require ~500 μs to find each of the selected tags. Once the selected items are found, removing the attributes would be fast.  But the real speed improvement is utilized when handing off to another selected element method. If the selected element information could not be handed off, `htmltools` would need to prep (~500 μs) and find (~500 μs) the selected tags again to be able to have composable functions. This approach would require a full `1000 μs` in addition to any exection done by the `fn` supplied to `$each`, whereas `$each()` currently finished within ~250 μs. Using a standard tag approach would also make finding `$parent()` tags very slow as all of the selected tags would need to be found before returning any ancestor tags.
